SET search_path TO public,public;
GRANT ALL ON SCHEMA public TO public;

CREATE TABLE public.auth_clients (
	id                   integer  NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	client_id            varchar(50)  NOT NULL ,
	client_secret        varchar(50)  NOT NULL ,
	redirect_url         varchar(200)   ,
	access_token_expiration integer DEFAULT 900 NOT NULL ,
	refresh_token_expiration integer DEFAULT 86400 NOT NULL ,
	auth_code_expiration integer DEFAULT 180 NOT NULL ,
	secret               varchar(50)  NOT NULL ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	deleted              bool DEFAULT false NOT NULL ,
	deleted_on           timestamptz   ,
	deleted_by           uuid   ,
	CONSTRAINT pk_auth_clients_id PRIMARY KEY ( id )
 );

CREATE TABLE public.groups (
	id                   uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	name                 varchar(200)  NOT NULL ,
	description          varchar(500)   ,
	photo_url            varchar(500)   ,
	created_by           uuid   ,
	modified_by          uuid   ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP  ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP  ,
	deleted              bool DEFAULT false  ,
	deleted_on           timestamptz   ,
	deleted_by           uuid   ,
	CONSTRAINT pk_groups_id PRIMARY KEY ( id )
 );

CREATE TABLE public.roles (
	id                   uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	name                 varchar(100)  NOT NULL ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	created_by           uuid   ,
	modified_by          uuid   ,
	deleted              bool DEFAULT false NOT NULL ,
	permissions          _text   ,
	role_type            integer DEFAULT 0 NOT NULL ,
	deleted_by           uuid   ,
	deleted_on           timestamptz   ,
	CONSTRAINT pk_roles_id PRIMARY KEY ( id )
 );

CREATE TABLE public.tenants (
	id                   uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	name                 varchar(100)  NOT NULL ,
	status               integer DEFAULT 0 NOT NULL ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	created_by           uuid   ,
	modified_by          uuid   ,
	deleted              bool DEFAULT false NOT NULL ,
	"key"                varchar(20)  NOT NULL ,
	address              varchar(500)   ,
	city                 varchar(100)   ,
	"state"              varchar(100)   ,
	zip                  varchar(25)   ,
	country              varchar(25)   ,
	deleted_on           timestamptz   ,
	deleted_by           uuid   ,
	CONSTRAINT pk_tenants_id PRIMARY KEY ( id ),
	CONSTRAINT idx_tenants UNIQUE ( "key" )
 );

CREATE TABLE public.users (
	id                   uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	first_name           varchar(50)  NOT NULL ,
	middle_name          varchar(50)   ,
	last_name            varchar(50)   ,
	username             varchar(150)  NOT NULL ,
	email                varchar(150)   ,
	phone                varchar(15)   ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	created_by           uuid   ,
	modified_by          uuid   ,
	deleted              bool DEFAULT false NOT NULL ,
	last_login           timestamptz   ,
	photo_url            varchar(250)   ,
	auth_client_ids      integer[]   ,
	gender               char(1)   ,
	dob                  date   ,
	designation          varchar(50)   ,
	default_tenant_id    uuid   ,
	deleted_by           uuid   ,
	deleted_on           timestamptz   ,
	CONSTRAINT pk_users_id PRIMARY KEY ( id )
 );

CREATE TABLE public.todo (
	id					 uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	title                varchar(50)  NOT NULL ,
	description          varchar(150)  NOT NULL ,
	items				 _text
 );

CREATE TABLE public.tenant_configs (
	id                   uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	config_key           varchar(100)  NOT NULL ,
	config_value         jsonb  NOT NULL ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	created_by           integer   ,
	modified_by          integer   ,
	deleted              bool DEFAULT false NOT NULL ,
	tenant_id            uuid  NOT NULL ,
	deleted_by           uuid   ,
	deleted_on           timestamptz   ,
	CONSTRAINT pk_tenant_configs_id PRIMARY KEY ( id )
 );

CREATE TABLE public.user_credentials (
	id                   uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	user_id              uuid  NOT NULL ,
	auth_provider        varchar(50) DEFAULT 'internal'::character varying NOT NULL ,
	auth_id              varchar(100)   ,
	auth_token           varchar(100)   ,
	"password"           varchar(60)   ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	deleted              bool DEFAULT false NOT NULL ,
	deleted_on           timestamptz   ,
	deleted_by           uuid   ,
	CONSTRAINT pk_user_credentials_id PRIMARY KEY ( id ),
	CONSTRAINT idx_user_credentials_user_id UNIQUE ( user_id )
 );

CREATE TABLE public.user_tenants (
	id                   uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	user_id              uuid  NOT NULL ,
	tenant_id            uuid  NOT NULL ,
	role_id              uuid  NOT NULL ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	deleted              bool DEFAULT false NOT NULL ,
	status               integer DEFAULT 0 NOT NULL ,
	locale               varchar(5)   ,
	deleted_by           uuid   ,
	deleted_on           timestamptz   ,
	CONSTRAINT pk_user_tenants_id PRIMARY KEY ( id )
 );

CREATE TABLE public.user_groups (
	id                   uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	user_tenant_id       uuid  NOT NULL ,
	group_id             uuid  NOT NULL ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP  ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP  ,
	deleted              bool DEFAULT false  ,
	created_by           uuid   ,
	modified_by          uuid   ,
	deleted_on           timestamptz   ,
	deleted_by           uuid   ,
	CONSTRAINT pk_user_groups_id PRIMARY KEY ( id )
 );

CREATE TABLE public.user_permissions (
	id                   uuid DEFAULT md5(random()::text || clock_timestamp()::text)::uuid NOT NULL ,
	user_tenant_id       uuid  NOT NULL ,
	permission           varchar(50)  NOT NULL ,
	allowed              bool  NOT NULL ,
	created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
	created_by           uuid   ,
	modified_by          uuid   ,
	deleted              bool DEFAULT false NOT NULL ,
	deleted_on           timestamptz   ,
	deleted_by           uuid   ,
	CONSTRAINT pk_user_permissions_id PRIMARY KEY ( id )
 );

CREATE OR REPLACE FUNCTION public.moddatetime()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.modified_on = now();
    RETURN NEW;
END;
$function$
;

CREATE TRIGGER mdt_auth_clients BEFORE UPDATE ON public.auth_clients FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

CREATE TRIGGER mdt_roles BEFORE UPDATE ON public.roles FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

CREATE TRIGGER mdt_tenant_configs BEFORE UPDATE ON public.tenant_configs FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

CREATE TRIGGER mdt_tenants BEFORE UPDATE ON public.tenants FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

CREATE TRIGGER mdt_user_credentials BEFORE UPDATE ON public.user_credentials FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

CREATE TRIGGER mdt_user_permissions BEFORE UPDATE ON public.user_permissions FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

CREATE TRIGGER mdt_user_tenants BEFORE UPDATE ON public.user_tenants FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

CREATE TRIGGER mdt_users BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

ALTER TABLE public.tenant_configs ADD CONSTRAINT fk_tenant_configs_tenants FOREIGN KEY ( tenant_id ) REFERENCES public.tenants( id );

ALTER TABLE public.user_credentials ADD CONSTRAINT fk_user_credentials_users FOREIGN KEY ( user_id ) REFERENCES public.users( id );

ALTER TABLE public.user_groups ADD CONSTRAINT fk_user_tenant FOREIGN KEY ( user_tenant_id ) REFERENCES public.user_tenants( id );

ALTER TABLE public.user_groups ADD CONSTRAINT fk_groups FOREIGN KEY ( group_id ) REFERENCES public.groups( id );

ALTER TABLE public.user_permissions ADD CONSTRAINT fk_user_permissions FOREIGN KEY ( user_tenant_id ) REFERENCES public.user_tenants( id );

ALTER TABLE public.user_tenants ADD CONSTRAINT fk_user_tenants_users FOREIGN KEY ( user_id ) REFERENCES public.users( id );

ALTER TABLE public.user_tenants ADD CONSTRAINT fk_user_tenants_tenants FOREIGN KEY ( tenant_id ) REFERENCES public.tenants( id );

ALTER TABLE public.user_tenants ADD CONSTRAINT fk_user_tenants_roles FOREIGN KEY ( role_id ) REFERENCES public.roles( id );

SET search_path
TO public,public;

/* Inserting auth clients */
insert into auth_clients
  (client_id, client_secret, secret)
values
  ('test_client_id', 'test_client_secret', 'secret');

-- Inserting roles
insert into roles
  (name, permissions, role_type)
values
  ('Admin', '{CreateTodo,UpdateTodo,DeleteTodo}', 0);

insert into roles
  (name, permissions, role_type)
values
  ('Others', '{}', 1);

-- Inserting tenants
insert into tenants
  (name, status, key)
values
  ('Master', 1, 'master');

-- Inserting Admin User
insert into users
    (first_name, last_name, username, email, default_tenant_id)
select 'Admin', 'User', 'admin@example.com', 'admin@example.com', id
from tenants
where key = 'master';

insert into user_tenants
    (user_id, tenant_id, status, role_id)
select (select id
    from users
    where username = 'admin@example.com'), (select id
    from tenants
    where key = 'master'), 1, id
from roles
where role_type = 0;

insert into user_credentials
    (user_id, auth_provider, password)
select id, 'internal', '$2a$10$TOLMGK43MjbibS8Jap2RXeHl3.4sJcR3eFbms2dBll2LTMggSK9hG'
from users
where username = 'admin@example.com';
update users set auth_client_ids = ARRAY[(select id from auth_clients where client_id = 'test_client_id')::integer];


UPDATE public.roles SET permissions = permissions || '{ViewMessage, CreateMessage, UpdateMessage, DeleteMessage, ViewMessageRecipient, CreateMessageRecipient, UpdateMessageRecipient, DeleteMessageRecipient}'
where role_type in (0,2);

DROP SCHEMA IF EXISTS logs
CASCADE;
CREATE SCHEMA logs;

SET search_path
TO public,public;
GRANT ALL ON SCHEMA public TO public;

CREATE TABLE logs.audit_logs
(
    id uuid DEFAULT md5(random()
    ::text || clock_timestamp
    ()::text)::uuid NOT NULL ,
  operation_name       varchar
    (10)  NOT NULL ,
  operation_time       timestamptz DEFAULT now
    () NOT NULL ,
  "table_name"         varchar
    (60)  NOT NULL ,
  log_type             varchar
    (100) DEFAULT 'APPLICATION_LOGS'::character varying  ,
  entity_id            varchar,
  user_id              varchar,
  "before"             jsonb ,
  "after"              jsonb ,
  CONSTRAINT pk_audit_logs_id PRIMARY KEY ( id )
 );


 CREATE  TABLE public.messages (
  id                   uuid DEFAULT (md5(((random())::text || (clock_timestamp())::text)))::uuid NOT NULL ,
  body                 text  NOT NULL ,
  channel_id           uuid  NOT NULL ,
  channel_type         varchar(200)  NOT NULL ,
  created_by           uuid   ,
  created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
  deleted              bool DEFAULT false NOT NULL ,
  deleted_by           uuid   ,
  deleted_on           timestamptz DEFAULT current_timestamp NOT NULL ,
  modified_by          uuid   ,
  modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
  status               integer DEFAULT 0 NOT NULL ,
  subject              varchar(200)   ,
  to_user_id           uuid   ,
  parent_message_id    uuid   ,
  CONSTRAINT pk_messages_id PRIMARY KEY ( id )
 );

COMMENT ON COLUMN public.messages.body IS 'The message body';

COMMENT ON COLUMN public.messages.channel_id IS 'The id of the type of channel(for now task)';

COMMENT ON COLUMN public.messages.channel_type IS 'The type of channel for example task';

COMMENT ON COLUMN public.messages.subject IS 'subject of the message';

COMMENT ON COLUMN public.messages.to_user_id IS 'For P2P message transfer, this would be the id of the user to whom message is sent';

COMMENT ON COLUMN public.messages.parent_message_id IS 'id of the message at which this reply exists';

ALTER TABLE public.messages ADD CONSTRAINT fk_messages_messages FOREIGN KEY ( parent_message_id ) REFERENCES public.messages( id );

CREATE  TABLE public.message_recipients (
  id                   uuid DEFAULT (md5(((random())::text || (clock_timestamp())::text)))::uuid NOT NULL ,
  channel_id           uuid  NOT NULL ,
  created_by           uuid   ,
  created_on           timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
  deleted              bool DEFAULT false NOT NULL ,
  deleted_by           uuid   ,
  deleted_on           timestamptz DEFAULT current_timestamp  ,
  forwarded_by         uuid   ,
  is_favorite          bool DEFAULT false NOT NULL ,
  is_forwarded         bool DEFAULT false NOT NULL ,
  is_read              bool DEFAULT false NOT NULL ,
  message_id           uuid  NOT NULL ,
  modified_by          uuid   ,
  modified_on          timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL ,
  recipient_id         uuid  NOT NULL ,
  CONSTRAINT pk_message_recipients_id PRIMARY KEY ( id )
 );

COMMENT ON COLUMN public.message_recipients.channel_id IS 'the id of the channel entity(task)';

COMMENT ON COLUMN public.message_recipients.forwarded_by IS 'The user id of the person who forwardes the message';

COMMENT ON COLUMN public.message_recipients.recipient_id IS 'user id of the recipient';

ALTER TABLE public.message_recipients ADD CONSTRAINT fk_message_recipients_messages FOREIGN KEY ( message_id ) REFERENCES public.messages( id );

CREATE OR REPLACE FUNCTION logs.audit_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
  DECLARE
    USER_ID VARCHAR;
    ENTITY_ID VARCHAR;
BEGIN
IF TG_OP = 'INSERT'
THEN
USER_ID := to_json(NEW)->'created_by';
ENTITY_ID := to_json(NEW)->'id';
INSERT INTO logs.audit_logs (
  operation_name,
  table_name,
  log_type,
  entity_id,
  user_id,
  after
  )
VALUES (
  TG_OP,
  TG_TABLE_NAME,
  TG_ARGV[0],
  ENTITY_ID,
  USER_ID,
  to_jsonb(NEW)
  );
RETURN NEW;
ELSIF TG_OP = 'UPDATE'
THEN
USER_ID := to_json(NEW)->'modified_by';
ENTITY_ID := to_json(NEW)->'id';
 INSERT INTO logs.audit_logs (
   operation_name,
   table_name,
   log_type,
   entity_id,
   user_id,
   before,
   after
   )
VALUES (
  TG_OP,
  TG_TABLE_NAME,
  TG_ARGV[0],
  ENTITY_ID,
  USER_ID,
  to_jsonb(OLD),
  to_jsonb(NEW)
  );
 RETURN NEW;
ELSIF TG_OP = 'DELETE'
THEN
USER_ID := to_json(OLD)->'modified_by';
ENTITY_ID := to_json(OLD)->'id';
INSERT INTO logs.audit_logs (
  operation_name,
  table_name,
  log_type,
  entity_id,
  user_id,
  before)
VALUES (
  TG_OP,
  TG_TABLE_NAME,
  TG_ARGV[0],
  ENTITY_ID,
  USER_ID,
  to_jsonb(OLD)
);
RETURN OLD;
END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.moddatetime()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.modified_on = now();
    RETURN NEW;
END;
$function$
;

CREATE TRIGGER mdt_messages BEFORE UPDATE ON public.messages FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

CREATE TRIGGER mdt_message_recipients BEFORE UPDATE ON public.message_recipients FOR EACH ROW EXECUTE PROCEDURE public.moddatetime('modified_on');

CREATE TRIGGER messages_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON public.messages FOR EACH ROW EXECUTE PROCEDURE logs.audit_trigger('MESSAGES_LOGS');

CREATE TRIGGER message_recipients_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON public.message_recipients FOR EACH ROW EXECUTE PROCEDURE logs.audit_trigger('MESSAGE_RECIPIENTS_LOGS');
