// Copyright IBM Corp. 2019,2020. All Rights Reserved.
// Node module: @loopback/cli
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT

'use strict';

const fse = require('fs-extra');
const semver = require('semver');
const chalk = require('chalk');
// import latestVersion from 'latest-version';
// const latestVersion = require('latest-version');

const cliPkg = require('../package.json');
const templateDeps = cliPkg.config.templateDependencies;
const packagejson = 'package.json';
/**
 * Print @loopback/* versions
 * @param log - A function to log information
 */
function printVersions(log = console.log) {
  const ver = cliPkg.version;
  log('@loopback/cli version: %s', ver);
  log('\n@loopback/* dependencies:');
  for (const d in templateDeps) {
    if (d.startsWith('@loopback/') && d !== '@loopback/cli') {
      log('  - %s: %s', d, templateDeps[d]);
    }
  }
}

/**
 * Check project dependencies against module versions from the cli template
 * @param generator - Yeoman generator instance
 */
async function checkDependencies(generator) {
  const pkg = generator.fs.readJSON(generator.destinationPath(packagejson));
  generator.packageJson = pkg;

  const isUpdate = generator.command === 'update';
  const pkgDeps = pkg
    ? {
        dependencies: {...pkg.dependencies},
        devDependencies: {...pkg.devDependencies},
        peerDependencies: {...pkg.peerDependencies},
      }
    : {};

  if (!pkg) {
    return getNoPkgDependencies(generator, isUpdate);
  }

  const dependentPackage = '@loopback/core';

  const projectDepsNames = isUpdate
    ? Object.keys(
        // Check dependencies, devDependencies, and peerDependencies
        {
          ...pkgDeps.dependencies,
          ...pkgDeps.devDependencies,
          ...pkgDeps.peerDependencies,
        },
      )
    : Object.keys(pkgDeps.dependencies);

  const isLBProj = isUpdate
    ? projectDepsNames.some(n => n.startsWith('@loopback/'))
    : projectDepsNames.includes(dependentPackage);

  if (!isLBProj) {
    const err = new Error(
      `No \`@loopback/core\` package found in the "dependencies" section of 
            ${generator.destinationPath(packagejson)}
            . The command must be run in a LoopBack project.`,
    );
    generator.exit(err);
    return undefined;
  }

  const incompatibleDeps = {
    dependencies: {},
    devDependencies: {},
    peerDependencies: {},
  };

  const found = getTemplateDependencies(
    generator,
    incompatibleDeps,
    false,
    pkgDeps,
  );
  if (!found) {
    // No incompatible dependencies
    if (generator.command === 'update') {
      generator.log(
        chalk.green(
          `The project dependencies are compatible with @loopback/cli@${cliPkg.version}`,
        ),
      );
    }
    return undefined;
  }

  const originalCliVersion = generator.config.get('update') || '<unknown>';
  generator.log(
    chalk.red(
      `The project was originally generated by @loopback/cli@${originalCliVersion}.`,
    ),
  );

  generator.log(
    chalk.red(
      `The following dependencies are incompatible with @loopback/cli@${cliPkg.version}:`,
    ),
  );
  for (const s in incompatibleDeps) {
    generator.log(s);
    for (const d in incompatibleDeps[s]) {
      generator.log(
        chalk.yellow('- %s: %s (cli %s)'),
        d,
        ...incompatibleDeps[s][d],
      );
    }
  }
  return incompatibleDeps;
}

function getTemplateDependencies(generator, incompatibleDeps, found, pkgDeps) {
  let isTemplateDep = found;
  for (const d in templateDeps) {
    for (const s in incompatibleDeps) {
      const versionRange = pkgDeps[s][d];
      if (isNotVersionRange(versionRange)) {
        continue;
      }
      // https://github.com/loopbackio/loopback-next/issues/2028
      // https://github.com/npm/node-semver/pull/238
      // semver.intersects does not like `*`, `x`, or `X`
      const templateDep = templateDeps[d];
      if (generator.options.semver === false) {
        // For `lb4 update` command, check exact matches
        isTemplateDep = isTemplateDependency(
          incompatibleDeps,
          s,
          templateDep,
          isTemplateDep,
          true,
        );
        continue;
      }
      if (semver.intersects(versionRange, templateDep)) {
        continue;
      }
      isTemplateDep = isTemplateDependency(incompatibleDeps, s, d, isTempDep);
    }
  }
  return isTemplateDep;
}
function isNotVersionRange(versionRange) {
  return !versionRange || versionRange.match(/^\*|x|X/);
}

function isTemplateDependency(
  incompatibleDeps,
  incompatibleDep,
  templateDep,
  versionRange,
  isTemplateDep,
  checkVersionRange = false,
) {
  let isTempDep = isTemplateDep;
  if (!checkVersionRange || versionRange !== templateDep) {
    incompatibleDeps[incompatibleDep][templateDep] = [
      versionRange,
      templateDeps[templateDep],
    ];
    isTempDep = true;
  }
  return isTempDep;
}

async function getNoPkgDependencies(generator, isUpdate) {
  if (isUpdate) {
    printVersions(generator.log);
    await checkCliVersion(generator.log);
    return undefined;
  }
  const err = new Error(
    `No package.json found in ${generator.destinationRoot()}. The command must be run in a LoopBack project.`,
  );
  generator.exit(err);
  return undefined;
}

/**
 * Update project dependencies with module versions from the cli template
 * @param pkg - Package json object for the project
 * @param generator - Yeoman generator instance
 */
function updateDependencies(generator) {
  const pkg =
    generator.packageJson ||
    generator.fs.readJSON(generator.destinationPath(packagejson));
  const depUpdates = [];
  for (const d in templateDeps) {
    if (
      pkg.dependencies &&
      pkg.dependencies[d] &&
      pkg.dependencies[d] !== templateDeps[d]
    ) {
      depUpdates.push(
        `- Dependency ${d}: ${pkg.dependencies[d]} => ${templateDeps[d]}`,
      );
      pkg.dependencies[d] = templateDeps[d];
    }
    if (
      pkg.devDependencies &&
      pkg.devDependencies[d] &&
      pkg.devDependencies[d] !== templateDeps[d]
    ) {
      depUpdates.push(
        `- DevDependency ${d}: ${pkg.devDependencies[d]} => ${templateDeps[d]}`,
      );
      pkg.devDependencies[d] = templateDeps[d];
    }
    if (
      pkg.peerDependencies &&
      pkg.peerDependencies[d] &&
      pkg.peerDependencies[d] !== templateDeps[d]
    ) {
      depUpdates.push(
        `- PeerDependency ${d}: ${pkg.devDependencies[d]} => ${templateDeps[d]}`,
      );
      pkg.devDependencies[d] = templateDeps[d];
    }
  }
  if (depUpdates.length) {
    depUpdates.sort();
    depUpdates.forEach(d => generator.log(d));
  }
  generator.log(
    chalk.red('Upgrading dependencies may break the current project.'),
  );
  generator.fs.writeJSON(generator.destinationPath(packagejson), pkg);
  // Remove `node_modules` force a fresh install
  if (generator.command === 'update' && !generator.options['skip-install']) {
    fse.removeSync(generator.destinationPath('node_modules'));
  }
  generator.pkgManagerInstall();
}

/**
 * Check the LoopBack project dependencies and versions
 * @param generator - Yeoman generator instance
 */
async function checkLoopBackProject(generator) {
  if (generator.shouldExit()) {
    return false;
  }

  const incompatibleDeps = await checkDependencies(generator);
  if (incompatibleDeps === null) {
    return false;
  }
  if (
    Object.keys({
      ...incompatibleDeps.dependencies,
      ...incompatibleDeps.devDependencies,
      ...incompatibleDeps.peerDependencies,
    }) == 0 //NOSONAR
  ) {
    return false;
  }

  const choices = [
    {
      name: 'Upgrade project dependencies',
      value: 'upgrade',
    },
    {
      name: 'Skip upgrading project dependencies',
      value: 'continue',
    },
  ];
  if (generator.command !== 'update') {
    choices.unshift({
      name: 'Abort now',
      value: 'abort',
    });
  }
  const prompts = [
    {
      name: 'decision',
      message: 'How do you want to proceed?',
      type: 'list',
      choices,
      default: 0,
    },
  ];
  const answers = await generator.prompt(prompts);
  if (answers && answers.decision === 'continue') {
    return false;
  }
  if (answers && answers.decision === 'upgrade') {
    updateDependencies(generator);
    return true;
  }
  generator.exit(new Error('Incompatible dependencies'));
  return undefined;
}

/**
 * Check if the current cli is out of date
 * @param log - Log function
 */
async function checkCliVersion(log = console.log) {
  return undefined;
}

exports.printVersions = printVersions;
exports.checkCliVersion = checkCliVersion;
exports.checkDependencies = checkDependencies;
exports.updateDependencies = updateDependencies;
exports.checkLoopBackProject = checkLoopBackProject;
exports.cliPkg = cliPkg;
